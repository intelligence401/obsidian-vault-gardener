/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultGardener
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// utils/AsyncVaultIndex.ts
var import_obsidian = require("obsidian");

// utils/RegexPatterns.ts
var REGEX_PATTERNS = {
  MASK_YAML: /^---\n[\s\S]*?\n---/,
  MASK_MATH: /(\$\$[\s\S]*?\$\$|\$(?=[^$\n]*[{}^_[\]|])[^$\n]+\$)/g,
  MASK_CODE: /(`{3}[\s\S]*?`{3}|`[^`\n]{1,1000}`)/g,
  get MASK_AREAS() {
    return /(`{3}[\s\S]*?`{3}|`[^`\n]{1,1000}`|\$\$[\s\S]*?\$\$|\$(?=[^$\n]*[{}^_[\]|])[^$\n]+\$|\[\[[^\]]{1,500}\]\]|\[[^\]]{1,500}\]\([^)]{1,500}\))/g;
  },
  TOKENIZER_SPLIT: /([^a-zA-Z0-9$_\\\-\u2018\u2019'{}]+)/,
  LINK_WITH_UNDERSCORE_ALIAS: /\[\[([^\]]{1,500})\|(_[^\]]{1,500})\]\]/g,
  UNDERSCORES_WRAPPER: /^[_$]+|[_$]+$/g,
  LINK_WITH_UNDERSCORE_TARGET: /\[\[(_[^\]|]{1,500}_)\]\]/g
};

// utils/AsyncVaultIndex.ts
var AsyncVaultIndex = class {
  constructor(app, settings) {
    this.app = app;
    const defaults = [
      "the",
      "and",
      "but",
      "for",
      "not",
      "this",
      "that",
      "with",
      "from",
      "into",
      "can",
      "are",
      "was",
      "were",
      "has",
      "have",
      "had",
      "will",
      "would",
      "what",
      "who",
      "how",
      "why",
      "when",
      "where",
      "which",
      "there",
      "here",
      "does",
      "do"
    ];
    this.stopWords = new Set(defaults);
    if (settings.ignoredWords) {
      const userWords = settings.ignoredWords.split(",").map((s) => s.trim().toLowerCase());
      userWords.forEach((w) => {
        if (w.length > 0) this.stopWords.add(w);
      });
    }
  }
  async buildIndex(files) {
    const index = /* @__PURE__ */ new Map();
    const shortFormRegistry = /* @__PURE__ */ new Map();
    for (const file of files) {
      const cache = await this.waitForCache(file);
      this.addTerm(index, shortFormRegistry, file.basename, file.basename);
      if (cache == null ? void 0 : cache.frontmatter) {
        const aliases = (0, import_obsidian.parseFrontMatterAliases)(cache.frontmatter);
        if (aliases) {
          aliases.forEach((alias) => {
            this.addTerm(index, shortFormRegistry, alias, file.basename);
          });
        }
      }
    }
    return { map: index, shortFormRegistry };
  }
  async waitForCache(file) {
    const current = this.app.metadataCache.getFileCache(file);
    if (current) return current;
    return new Promise((resolve) => {
      let ref;
      const timeout = setTimeout(() => {
        this.app.metadataCache.offref(ref);
        resolve(null);
      }, 2e3);
      ref = this.app.metadataCache.on("changed", (changedFile) => {
        if (changedFile.path === file.path) {
          clearTimeout(timeout);
          this.app.metadataCache.offref(ref);
          resolve(this.app.metadataCache.getFileCache(file));
        }
      });
    });
  }
  addTerm(index, registry, rawTerm, target) {
    if (!rawTerm) return;
    const term = rawTerm.trim();
    const cleanRaw = term.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
    const cleanKey = cleanRaw.toLowerCase();
    if (cleanKey.length < 2 && !cleanKey.includes("$")) return;
    if (this.stopWords.has(cleanKey)) {
      if (cleanRaw !== cleanRaw.toUpperCase()) {
        return;
      }
    }
    index.set(cleanKey, target);
    if (cleanRaw.length <= 3) {
      if (!registry.has(cleanKey)) {
        registry.set(cleanKey, /* @__PURE__ */ new Set());
      }
      const set = registry.get(cleanKey);
      if (set) {
        set.add(cleanRaw);
      }
    }
  }
};

// processors/FilenameRenamer.ts
var import_obsidian2 = require("obsidian");
var FilenameRenamer = class {
  constructor(app) {
    this.greekMap = {
      "\\alpha": "alpha",
      "\\beta": "beta",
      "\\gamma": "gamma",
      "\\delta": "delta",
      "\\epsilon": "epsilon",
      "\\phi": "phi",
      "\\mu": "mu",
      "\\lambda": "lambda"
    };
    this.app = app;
  }
  async process(files) {
    const history = /* @__PURE__ */ new Map();
    let count = 0;
    const queue = [...files];
    for (const file of queue) {
      if (file.basename.includes("$")) {
        const result = await this.handleRename(file);
        if (result) {
          history.set(result.newPath, result.originalName);
          count++;
        }
      }
    }
    if (count > 0) new import_obsidian2.Notice(`Renamer: Moved ${count} files.`);
    return history;
  }
  async handleRename(file) {
    const originalName = file.basename;
    let newName = originalName.replace(/\$([^$]+)\$/g, (match, inner) => {
      const trimmed = inner.trim();
      return this.greekMap[trimmed] || trimmed.replace(/\\/g, "");
    });
    newName = newName.replace(/\s+/g, " ").trim();
    if (newName === originalName) return null;
    const parentPath = file.parent ? file.parent.path : "";
    const rawPath = parentPath === "/" ? newName + ".md" : `${parentPath}/${newName}.md`;
    const newPath = (0, import_obsidian2.normalizePath)(rawPath);
    if (await this.app.vault.adapter.exists(newPath)) {
      console.warn(`Renamer: Skipping ${originalName}, target exists.`);
      return null;
    }
    console.debug(`[RENAMER] Moving "${originalName}" -> "${newName}"`);
    console.debug(`[RENAMER] Key generated: "${newPath}"`);
    await this.app.fileManager.renameFile(file, newPath);
    return { newPath, originalName };
  }
};

// processors/FrontmatterSafeOps.ts
var FrontmatterSafeOps = class {
  constructor(app) {
    this.app = app;
  }
  async updateAliases(file, generatorFn) {
    let isModified = false;
    try {
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        let current = [];
        if (frontmatter.aliases) {
          if (Array.isArray(frontmatter.aliases)) {
            current = frontmatter.aliases.map(String);
          } else if (typeof frontmatter.aliases === "string") {
            current = [frontmatter.aliases];
          }
        }
        const roots = /* @__PURE__ */ new Set();
        roots.add(file.basename);
        current.forEach((a) => roots.add(a.trim()));
        const newSet = generatorFn(roots);
        const finalAliases = [];
        newSet.forEach((alias) => {
          if (alias === file.basename) return;
          if (alias.includes("$")) {
            finalAliases.push(alias);
          } else if (this.isStrictlyValid(alias)) {
            finalAliases.push(alias);
          }
        });
        finalAliases.sort();
        current.sort();
        if (JSON.stringify(finalAliases) !== JSON.stringify(current)) {
          frontmatter.aliases = finalAliases;
          isModified = true;
        }
      });
    } catch (e) {
      console.error(`FrontmatterOps: Failed to update ${file.path}`, e);
    }
    return isModified;
  }
  isStrictlyValid(alias) {
    if (!alias) return false;
    if (alias.includes("__")) return false;
    const starts = alias.startsWith("_");
    const ends = alias.endsWith("_");
    if (starts !== ends) return false;
    return true;
  }
};

// processors/AliasGenerator.ts
var AliasGenerator = class {
  constructor(app) {
    this.renameHistory = /* @__PURE__ */ new Map();
    this.greekMap = {
      "\\alpha": "alpha",
      "\\beta": "beta",
      "\\gamma": "gamma",
      "\\delta": "delta",
      "\\epsilon": "epsilon",
      "\\phi": "phi",
      "\\mu": "mu",
      "\\lambda": "lambda"
    };
    this.app = app;
    this.fmOps = new FrontmatterSafeOps(app);
  }
  async process(files, history) {
    if (history) this.renameHistory = history;
    let count = 0;
    for (const file of files) {
      const modified = await this.fmOps.updateAliases(file, (roots) => {
        return this.generateFromRoots(roots, file.path);
      });
      if (modified) count++;
    }
    return count;
  }
  generateFromRoots(roots, filePath) {
    if (this.renameHistory.has(filePath)) {
      const historyItem = this.renameHistory.get(filePath);
      if (historyItem) roots.add(historyItem);
    }
    const finalAliases = /* @__PURE__ */ new Set();
    const generationSeeds = /* @__PURE__ */ new Set();
    for (const root of roots) {
      if (root.includes("$")) {
        finalAliases.add(root);
        let plain = root.replace(/\$/g, "");
        for (const [key, val] of Object.entries(this.greekMap)) {
          const regex = new RegExp(key.replace(/\\/g, "\\\\"), "g");
          plain = plain.replace(regex, val);
        }
        plain = plain.replace(/\\/g, "");
        if (plain.length >= 2) generationSeeds.add(plain.trim());
        continue;
      }
      let clean = root;
      if (clean.startsWith("_") && clean.endsWith("_")) {
        clean = clean.replace(/^_+|_+$/g, "");
      }
      if (/s{3,}$/.test(clean)) continue;
      if (clean.length >= 2) generationSeeds.add(clean);
    }
    for (const seed of generationSeeds) {
      finalAliases.add(seed);
      if (!seed.endsWith("ss")) finalAliases.add(seed + "s");
      if (!seed.endsWith("s")) finalAliases.add(seed + "ss");
      if (seed.endsWith("um")) finalAliases.add(seed.slice(0, -2) + "a");
      if (seed.endsWith("us")) finalAliases.add(seed.slice(0, -2) + "i");
      if (seed.endsWith("is")) finalAliases.add(seed.slice(0, -2) + "es");
      if (seed.endsWith("a") && !seed.endsWith("ia")) finalAliases.add(seed + "e");
    }
    const wrappers = /* @__PURE__ */ new Set();
    for (const item of finalAliases) {
      if (!item.includes("$") && !item.startsWith("_")) {
        wrappers.add(`_${item}_`);
      }
    }
    wrappers.forEach((w) => finalAliases.add(w));
    for (const item of finalAliases) {
      if (!item || item.trim().length === 0) finalAliases.delete(item);
      if (/s{3,}$/.test(item) || /s{3,}_$/.test(item)) finalAliases.delete(item);
    }
    return finalAliases;
  }
};

// utils/Tokenizer.ts
var Tokenizer = class {
  static tokenize(text) {
    return text.split(REGEX_PATTERNS.TOKENIZER_SPLIT);
  }
  static isWord(token) {
    return /[a-zA-Z0-9$_\-\u2018\u2019'{} \\]/.test(token);
  }
};

// processors/WindowMatcher.ts
var WindowMatcher = class {
  static findMatch(tokens, currentIndex, maxWindow, aliasMap, startWords, shortFormRegistry) {
    const firstToken = tokens[currentIndex];
    const cleanFirst = firstToken.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "").toLowerCase();
    if (!startWords.has(cleanFirst)) {
      return { matched: false, advanceIndices: 0, linkText: "", target: "" };
    }
    for (let len = maxWindow; len >= 1; len--) {
      const phraseTokens = [];
      let validWordsFound = 0;
      let offset = 0;
      for (let k = 0; k < 50; k++) {
        if (currentIndex + k >= tokens.length) break;
        const t = tokens[currentIndex + k];
        if (Tokenizer.isWord(t)) {
          phraseTokens.push(t);
          validWordsFound++;
        } else {
          if (validWordsFound < len) {
            phraseTokens.push(t);
          }
        }
        offset = k;
        if (validWordsFound === len) break;
      }
      if (validWordsFound !== len) continue;
      const candidateRaw = phraseTokens.join("");
      const candidateClean = candidateRaw.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
      const candidateKey = candidateClean.replace(/\s+/g, " ").toLowerCase();
      if (aliasMap.has(candidateKey)) {
        const target = aliasMap.get(candidateKey);
        if (!target) continue;
        if (candidateClean.length <= 3) {
          const allowedForms = shortFormRegistry.get(candidateKey);
          if (allowedForms && !allowedForms.has(candidateClean)) {
            continue;
          }
        }
        if (/^\d+$/.test(candidateClean) && !candidateClean.includes("$")) {
          continue;
        }
        return {
          matched: true,
          advanceIndices: offset,
          linkText: candidateRaw,
          target
        };
      }
    }
    return { matched: false, advanceIndices: 0, linkText: "", target: "" };
  }
};

// processors/ContextMasker.ts
var ContextMasker = class {
  constructor() {
    this.masks = [];
  }
  mask(text, aliasMap) {
    this.masks = [];
    let workingText = text;
    const createMask = (match) => {
      if (aliasMap && match.startsWith("$")) {
        const cleanKey = match.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "").toLowerCase();
        if (aliasMap.has(cleanKey)) {
          return match;
        }
      }
      this.masks.push(match);
      return `___MASK_${this.masks.length - 1}___`;
    };
    workingText = workingText.replace(REGEX_PATTERNS.MASK_YAML, createMask);
    workingText = workingText.replace(REGEX_PATTERNS.MASK_AREAS, createMask);
    return workingText;
  }
  unmask(text) {
    return text.replace(/___MASK_(\d+)___/g, (match, indexStr) => {
      const index = parseInt(indexStr, 10);
      if (index >= 0 && index < this.masks.length) {
        return this.masks[index];
      }
      console.error(`ContextMasker: Could not restore mask ${index}`);
      return match;
    });
  }
};

// processors/RecursionGuard.ts
var RecursionGuard = class {
  static isSafeToLink(targetBasename, currentFile, candidateText, precedingContext = "") {
    if (precedingContext.trim().endsWith("[")) {
      return false;
    }
    return true;
  }
};

// processors/AutoLinker.ts
var AutoLinker = class {
  constructor(app, indexData) {
    this.maxWindow = 0;
    this.YIELD_THRESHOLD = 1e3;
    this.app = app;
    this.aliasMap = indexData.map;
    this.shortFormRegistry = indexData.shortFormRegistry;
    this.masker = new ContextMasker();
    this.startWords = /* @__PURE__ */ new Set();
    for (const key of this.aliasMap.keys()) {
      const tokens = Tokenizer.tokenize(key);
      const firstWord = tokens.find((t) => Tokenizer.isWord(t));
      if (firstWord) {
        const cleanStart = firstWord.replace(/^[_$]+|[_$]+$/g, "").toLowerCase();
        this.startWords.add(cleanStart);
      }
      const wordCount = tokens.filter((t) => Tokenizer.isWord(t)).length;
      this.maxWindow = Math.max(this.maxWindow, wordCount);
    }
  }
  async yieldToMain() {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  async process(files) {
    let count = 0;
    let skipped = 0;
    for (const file of files) {
      try {
        const originalContent = await this.app.vault.read(file);
        const linkedContent = await this.linkText(originalContent, file);
        if (linkedContent === originalContent) continue;
        await this.app.vault.process(file, (currentOnDisk) => {
          if (currentOnDisk !== originalContent) {
            skipped++;
            return currentOnDisk;
          }
          count++;
          return linkedContent;
        });
      } catch (e) {
        console.error(`AutoLinker failed: ${file.path}`, e);
      }
    }
    if (skipped > 0) console.debug(`Skipped ${skipped} files due to user activity.`);
    return count;
  }
  async linkText(text, file) {
    this.masker = new ContextMasker();
    const working = this.masker.mask(text, this.aliasMap);
    const tokens = Tokenizer.tokenize(working);
    const resultTokens = [...tokens];
    for (let i = 0; i < tokens.length; i++) {
      if (i % this.YIELD_THRESHOLD === 0) await this.yieldToMain();
      const token = tokens[i];
      if (!Tokenizer.isWord(token)) continue;
      if (token.startsWith("___MASK_")) continue;
      const match = WindowMatcher.findMatch(
        tokens,
        i,
        this.maxWindow,
        this.aliasMap,
        this.startWords,
        this.shortFormRegistry
      );
      if (match.matched) {
        const prevToken = i > 0 ? tokens[i - 1] : "";
        if (RecursionGuard.isSafeToLink(match.target, file, match.linkText, prevToken)) {
          let link = "";
          let shouldSkip = false;
          if (match.linkText.includes("$")) {
            let lookAheadStr = "";
            const lookAheadLimit = 15;
            for (let k = 1; k < lookAheadLimit; k++) {
              const idx = i + match.advanceIndices + k;
              if (idx >= tokens.length) break;
              lookAheadStr += tokens[idx];
            }
            const unmaskedLookAhead = this.masker.unmask(lookAheadStr);
            const targetPattern = `[[${match.target}]]`;
            if (unmaskedLookAhead.trim().startsWith(targetPattern)) {
              shouldSkip = true;
            } else {
              link = `${match.linkText} [[${match.target}]]`;
            }
          } else {
            link = match.linkText === match.target ? `[[${match.target}]]` : `[[${match.target}|${match.linkText}]]`;
          }
          if (!shouldSkip) {
            resultTokens[i] = link;
            for (let j = 1; j <= match.advanceIndices; j++) {
              resultTokens[i + j] = "";
            }
            i += match.advanceIndices;
          }
        }
      }
    }
    const unmaskedText = this.masker.unmask(resultTokens.join(""));
    return this.escapeLinksInTables(unmaskedText);
  }
  escapeLinksInTables(text) {
    const lines = text.split("\n");
    const tableLineRegex = /^\s*\|.*\|\s*$/;
    for (let i = 0; i < lines.length; i++) {
      if (tableLineRegex.test(lines[i])) {
        lines[i] = lines[i].replace(/\[\[([^\]|]+)\|([^\]]+)\]\]/g, (match, target, alias) => {
          return `[[${target}\\|${alias}]]`;
        });
      }
    }
    return lines.join("\n");
  }
};

// processors/LinkSanitizer.ts
var LinkSanitizer = class {
  constructor(app, indexData) {
    this.app = app;
    this.aliasMap = indexData.map;
    this.shortFormRegistry = indexData.shortFormRegistry;
  }
  async process(files) {
    let count = 0;
    for (const file of files) {
      try {
        await this.app.vault.process(file, (text) => {
          const clean = this.sanitizeContent(text);
          if (clean !== text) {
            count++;
            return clean;
          }
          return text;
        });
      } catch (e) {
        console.error(`Sanitizer failed: ${file.path}`, e);
      }
    }
    return count;
  }
  sanitizeContent(text) {
    const masks = [];
    const createMask = (match) => {
      masks.push(match);
      return `___MASK_${masks.length - 1}___`;
    };
    let working = text;
    working = working.replace(REGEX_PATTERNS.MASK_YAML, createMask);
    working = working.replace(REGEX_PATTERNS.MASK_CODE, createMask);
    working = working.replace(REGEX_PATTERNS.LINK_WITH_UNDERSCORE_ALIAS, (match, target, alias) => {
      const inner = alias.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
      if (target.toLowerCase() === inner.toLowerCase()) return `_[[${target}]]_`;
      return `_[[${target}|${inner}]]_`;
    });
    const VALIDATION_REGEX = /\[\[([^\]|]+)\|([^\]]+)\]\]/g;
    working = working.replace(VALIDATION_REGEX, (match, targetRaw, aliasRaw) => {
      const target = targetRaw.trim();
      const alias = aliasRaw.trim();
      if (alias.includes("$")) {
        return alias;
      }
      const cleanAlias = alias.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "").toLowerCase();
      if (!this.aliasMap.has(cleanAlias)) return alias;
      const exactAlias = alias.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
      if (exactAlias.length <= 3) {
        const allowedForms = this.shortFormRegistry.get(cleanAlias);
        if (allowedForms && !allowedForms.has(exactAlias)) {
          return alias;
        }
      }
      const registeredTarget = this.aliasMap.get(cleanAlias);
      if (registeredTarget && registeredTarget.toLowerCase() !== target.toLowerCase()) {
        return match;
      }
      return match;
    });
    return working.replace(/___MASK_(\d+)___/g, (m, i) => masks[parseInt(i, 10)] || m);
  }
};

// settings/GardenerSettingTab.ts
var import_obsidian3 = require("obsidian");
var GardenerSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Vault gardener settings").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Active processors").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Enable filename renamer").setDesc('Converts "$a$" to "a" in filenames while preserving the alias.').addToggle((toggle) => toggle.setValue(this.plugin.settings.enableRenamer).onChange(async (value) => {
      this.plugin.settings.enableRenamer = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Enable alias generator").setDesc("Generates plurals and clean variations for your frontmatter.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAliases).onChange(async (value) => {
      this.plugin.settings.enableAliases = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Enable link sanitizer").setDesc("Fixes malformed links and applies scientific citation styles.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSanitizer).onChange(async (value) => {
      this.plugin.settings.enableSanitizer = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Enable auto-linker").setDesc("Scans text and creates new links based on your vault index.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoLinker).onChange(async (value) => {
      this.plugin.settings.enableAutoLinker = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Safety & exclusions").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Skip confirmation modal").setDesc("If enabled, the cleanup command will execute immediately without asking for confirmation. Use with caution!").addToggle((toggle) => toggle.setValue(this.plugin.settings.skipConfirmationModal).onChange(async (value) => {
      this.plugin.settings.skipConfirmationModal = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Ignored folders").setDesc('Comma-separated list of folder paths to skip (e.g. "Templates, Archive/Old").').addTextArea((text) => text.setPlaceholder("Templates, Archive").setValue(this.plugin.settings.ignoredFolders).onChange(async (value) => {
      this.plugin.settings.ignoredFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Ignored stopwords").setDesc("Comma-separated list of words to never link.").addTextArea((text) => text.setPlaceholder("the, and, or").setValue(this.plugin.settings.ignoredWords).onChange(async (value) => {
      this.plugin.settings.ignoredWords = value;
      await this.plugin.saveSettings();
    }));
  }
};

// modals/ConfirmationModal.ts
var import_obsidian4 = require("obsidian");
var ConfirmationModal = class extends import_obsidian4.Modal {
  constructor(app, settings, onConfirm) {
    super(app);
    this.onConfirm = onConfirm;
    this.settings = settings;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.createEl("h2", { text: "\u{1F6A8} WARNING! \u{1F6A8}" });
    contentEl.createEl("p", { text: "You are about to run Vault Gardener. This plugin performs SUBSTANTIAL automated modifications:" });
    const listEl = contentEl.createEl("ul");
    listEl.createEl("li", { text: "FILE RENAMING" });
    listEl.createEl("li", { text: "YAML FRONTMATTER ALIASES will be GENERATED, UPDATED, or DELETED." });
    listEl.createEl("li", { text: "TEXT will be CHANGED to ADD/REMOVE LINKS." });
    contentEl.createEl("p", { text: "Running Vault Gardener could lead to unintended changes in your vault." });
    contentEl.createEl("p", { text: "!!!BACKUP YOUR VAULT BEFORE PROCEEDING!!!", cls: "mod-warning" });
    new import_obsidian4.Setting(contentEl).setName("I understand the risks and do not want to see this warning again.").addToggle((toggle) => toggle.setValue(this.settings.skipConfirmationModal).onChange(async (value) => {
      var _a;
      this.settings.skipConfirmationModal = value;
      await ((_a = this.app.plugins.getPlugin("vault-gardener")) == null ? void 0 : _a.saveSettings());
    }));
    new import_obsidian4.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => this.close())).addButton((btn) => btn.setButtonText("Proceed with Caution").setCta().onClick(() => {
      this.close();
      this.onConfirm();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// main.ts
var DEFAULT_SETTINGS = {
  enableRenamer: true,
  enableAliases: true,
  enableSanitizer: true,
  enableAutoLinker: true,
  ignoredWords: "the, and, but, for, not, this, that, with, from, into",
  ignoredFolders: "Templates, Archive, bin",
  skipConfirmationModal: false
};
var VaultGardener = class extends import_obsidian5.Plugin {
  async onload() {
    console.debug("Vault Gardener: Loading plugin...");
    await this.loadSettings();
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("");
    this.addRibbonIcon("sprout", "Run vault gardener", (_evt) => {
      if (this.settings.skipConfirmationModal) {
        void this.runSequence();
      } else {
        new ConfirmationModal(this.app, this.settings, () => {
          void this.runSequence();
        }).open();
      }
    });
    this.addSettingTab(new GardenerSettingTab(this.app, this));
    this.addCommand({
      id: "run-gardener",
      name: "Run cleanup",
      callback: () => {
        if (this.settings.skipConfirmationModal) {
          void this.runSequence();
        } else {
          new ConfirmationModal(this.app, this.settings, () => {
            void this.runSequence();
          }).open();
        }
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async runSequence() {
    new import_obsidian5.Notice("\u{1F331} Gardening started...");
    this.statusBarItem.setText("\u{1F331} Gardening: Preparing...");
    const allFiles = this.app.vault.getMarkdownFiles();
    const ignoredPaths = this.settings.ignoredFolders.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
    const files = allFiles.filter((file) => {
      for (const ignored of ignoredPaths) {
        if (file.path.startsWith(ignored)) return false;
      }
      return true;
    });
    console.debug(`Processing ${files.length} files (Excluded ${allFiles.length - files.length})`);
    const indexer = new AsyncVaultIndex(this.app, this.settings);
    const renamer = new FilenameRenamer(this.app);
    const generator = new AliasGenerator(this.app);
    try {
      let renameHistory = /* @__PURE__ */ new Map();
      if (this.settings.enableRenamer) {
        this.statusBarItem.setText("\u{1F331} Phase 1: Renaming...");
        renameHistory = await renamer.process(files);
      }
      if (this.settings.enableAliases) {
        this.statusBarItem.setText("\u{1F331} Phase 2: Aliases...");
        await generator.process(files, renameHistory);
      }
      let indexData = null;
      if (this.settings.enableSanitizer || this.settings.enableAutoLinker) {
        this.statusBarItem.setText("\u{1F331} Phase 3: Indexing...");
        indexData = await indexer.buildIndex(files);
      }
      if (this.settings.enableSanitizer && indexData) {
        this.statusBarItem.setText("\u{1F331} Phase 4: Pruning...");
        await new LinkSanitizer(this.app, indexData).process(files);
        this.statusBarItem.setText("\u{1F331} Syncing cache...");
        await this.sleep(300);
      }
      if (this.settings.enableAutoLinker && indexData) {
        this.statusBarItem.setText("\u{1F331} Phase 5: Linking...");
        await new AutoLinker(this.app, indexData).process(files);
      }
      new import_obsidian5.Notice("\u2705 Gardening complete!");
    } catch (e) {
      console.error("Gardener Failed:", e);
      new import_obsidian5.Notice("\u274C Error. Check Console.");
    } finally {
      this.statusBarItem.setText("");
    }
  }
  sleep(ms) {
    return new Promise((resolve) => setTimeout(resolve, ms));
  }
};
