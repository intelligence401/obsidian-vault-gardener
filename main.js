/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => VaultGardener
});
module.exports = __toCommonJS(main_exports);
var import_obsidian5 = require("obsidian");

// utils/AsyncVaultIndex.ts
var import_obsidian = require("obsidian");

// utils/RegexPatterns.ts
var REGEX_PATTERNS = {
  MASK_YAML: /^---\n[\s\S]*?\n---/,
  MASK_MATH: /(\$\$[\s\S]*?\$\$|\$(?=[^$\n]*[{}^_[\]|])[^$\n]+\$)/g,
  MASK_CODE: /(`{3}[\s\S]*?`{3}|`[^`\n]{1,1000}`)/g,
  MASK_TABLE_ROW: /(^|\n)\s*\|.*\|\s*(?=\n|$)/g,
  get MASK_AREAS() {
    return /(`{3}[\s\S]*?`{3}|`[^`\n]{1,1000}`|\$\$[\s\S]*?\$\$|\$(?=[^$\n]*[{}^_[\]|])[^$\n]+\$|\[\[[^\]]{1,500}\]\]|\[[^\]]{1,500}\]\([^)]{1,500}\))/g;
  },
  TOKENIZER_SPLIT: /([^a-zA-Z0-9$_\-\u2018\u2019'{}\u2070-\u209F\x2F]+)/,
  LINK_WITH_UNDERSCORE_ALIAS: /\[\[([^\]]{1,500})\|(_[^\]]{1,500})\]\]/g,
  UNDERSCORES_WRAPPER: /^[_$]+|[_$]+$/g,
  LINK_WITH_UNDERSCORE_TARGET: /\[\[(_[^\]|]{1,500}_)\]\]/g
};

// utils/AsyncVaultIndex.ts
var AsyncVaultIndex = class {
  constructor(app, settings) {
    this.app = app;
    const defaults = [
      "the",
      "and",
      "but",
      "for",
      "not",
      "this",
      "that",
      "with",
      "from",
      "into",
      "can",
      "are",
      "was",
      "were",
      "has",
      "have",
      "had",
      "will",
      "would",
      "what",
      "who",
      "how",
      "why",
      "when",
      "where",
      "which",
      "there",
      "here",
      "does",
      "do"
    ];
    this.stopWords = new Set(defaults);
    if (settings.ignoredWords) {
      const userWords = settings.ignoredWords.split(",").map((s) => s.trim().toLowerCase());
      userWords.forEach((w) => {
        if (w.length > 0) this.stopWords.add(w);
      });
    }
  }
  async buildIndex(files) {
    const candidateMap = /* @__PURE__ */ new Map();
    const shortFormRegistry = /* @__PURE__ */ new Map();
    for (const file of files) {
      const cache = await this.waitForCache(file);
      const target = file.basename;
      this.collectTerm(candidateMap, shortFormRegistry, target, target);
      if (cache == null ? void 0 : cache.frontmatter) {
        const aliases = (0, import_obsidian.parseFrontMatterAliases)(cache.frontmatter);
        if (aliases) {
          aliases.forEach((alias) => {
            this.collectTerm(candidateMap, shortFormRegistry, alias, target);
          });
        }
      }
    }
    const uniqueMap = /* @__PURE__ */ new Map();
    const multiMap = /* @__PURE__ */ new Map();
    for (const [alias, targets] of candidateMap.entries()) {
      const targetArray = Array.from(targets);
      if (targetArray.length === 1) {
        uniqueMap.set(alias, targetArray[0]);
      } else if (targetArray.length > 1) {
        multiMap.set(alias, targetArray);
      }
    }
    return { uniqueMap, multiMap, shortFormRegistry };
  }
  collectTerm(map, registry, rawTerm, target) {
    if (!rawTerm) return;
    const term = rawTerm.trim();
    const cleanRaw = term.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
    const cleanKey = cleanRaw.toLowerCase();
    if (cleanKey.length < 2 && !cleanKey.includes("$")) return;
    if (this.stopWords.has(cleanKey)) {
      if (cleanRaw !== cleanRaw.toUpperCase()) {
        return;
      }
    }
    if (!map.has(cleanKey)) {
      map.set(cleanKey, /* @__PURE__ */ new Set());
    }
    map.get(cleanKey).add(target);
    if (cleanRaw.length <= 3) {
      if (!registry.has(cleanKey)) {
        registry.set(cleanKey, /* @__PURE__ */ new Set());
      }
      registry.get(cleanKey).add(cleanRaw);
    }
  }
  async waitForCache(file) {
    const current = this.app.metadataCache.getFileCache(file);
    if (current) return current;
    return new Promise((resolve) => {
      const timerControl = { ref: null };
      const timeout = setTimeout(() => {
        if (timerControl.ref) this.app.metadataCache.offref(timerControl.ref);
        resolve(null);
      }, 2e3);
      timerControl.ref = this.app.metadataCache.on("changed", (changedFile) => {
        if (changedFile.path === file.path) {
          clearTimeout(timeout);
          if (timerControl.ref) this.app.metadataCache.offref(timerControl.ref);
          resolve(this.app.metadataCache.getFileCache(file));
        }
      });
    });
  }
};

// processors/FilenameRenamer.ts
var import_obsidian2 = require("obsidian");
var FilenameRenamer = class {
  constructor(app) {
    this.greekMap = {
      "\\alpha": "alpha",
      "\\beta": "beta",
      "\\gamma": "gamma",
      "\\delta": "delta",
      "\\epsilon": "epsilon",
      "\\phi": "phi",
      "\\mu": "mu",
      "\\lambda": "lambda"
    };
    this.app = app;
  }
  async process(files) {
    const history = /* @__PURE__ */ new Map();
    let count = 0;
    const queue = [...files];
    for (const file of queue) {
      if (file.basename.startsWith("Untitled")) continue;
      const hasMath = file.basename.includes("$");
      const hasWrapper = file.basename.startsWith("_") && file.basename.endsWith("_");
      if (hasMath || hasWrapper) {
        const result = await this.handleRename(file);
        if (result) {
          history.set(result.newPath, result.originalName);
          count++;
        }
      }
    }
    if (count > 0) new import_obsidian2.Notice(`Renamer: Moved ${count} files.`);
    return history;
  }
  async handleRename(file) {
    const originalName = file.basename;
    let newName = originalName;
    if (newName.startsWith("_") && newName.endsWith("_")) {
      newName = newName.slice(1, -1);
    }
    if (newName.includes("$")) {
      newName = newName.replace(/\$([^$]+)\$/g, (match, inner) => {
        let trimmed = inner.trim();
        for (const [key, val] of Object.entries(this.greekMap)) {
          const regex = new RegExp(key.replace(/\\/g, "\\\\"), "g");
          trimmed = trimmed.replace(regex, val);
        }
        trimmed = trimmed.replace(/[_^{}\\]/g, "");
        return trimmed;
      });
    }
    newName = newName.replace(/\s+/g, " ").trim();
    if (newName === originalName) return null;
    const parentPath = file.parent ? file.parent.path : "";
    const rawPath = parentPath === "/" ? newName + ".md" : `${parentPath}/${newName}.md`;
    const newPath = (0, import_obsidian2.normalizePath)(rawPath);
    if (await this.app.vault.adapter.exists(newPath)) {
      console.warn(`Renamer: Skipping ${originalName}, target exists.`);
      return null;
    }
    console.debug(`[RENAMER] Moving "${originalName}" -> "${newName}"`);
    await this.app.fileManager.renameFile(file, newPath);
    return { newPath, originalName };
  }
};

// processors/FrontmatterSafeOps.ts
var FrontmatterSafeOps = class {
  constructor(app) {
    this.app = app;
  }
  async updateAliases(file, generatorFn) {
    let isModified = false;
    try {
      await this.app.fileManager.processFrontMatter(file, (frontmatter) => {
        let current = [];
        if (frontmatter.aliases) {
          if (Array.isArray(frontmatter.aliases)) {
            current = frontmatter.aliases.map(String);
          } else if (typeof frontmatter.aliases === "string") {
            current = [frontmatter.aliases];
          }
        }
        const roots = /* @__PURE__ */ new Set();
        roots.add(file.basename);
        current.forEach((a) => roots.add(a.trim()));
        const newSet = generatorFn(roots);
        const finalAliases = [];
        newSet.forEach((alias) => {
          if (alias === file.basename) return;
          if (alias.includes("$")) {
            finalAliases.push(alias);
          } else if (this.isStrictlyValid(alias)) {
            finalAliases.push(alias);
          }
        });
        finalAliases.sort();
        current.sort();
        if (JSON.stringify(finalAliases) !== JSON.stringify(current)) {
          frontmatter.aliases = finalAliases;
          isModified = true;
        }
      });
    } catch (e) {
      console.error(`FrontmatterOps: Failed to update ${file.path}`, e);
    }
    return isModified;
  }
  isStrictlyValid(alias) {
    if (!alias) return false;
    if (alias.includes("__")) return false;
    const starts = alias.startsWith("_");
    const ends = alias.endsWith("_");
    if (starts !== ends) return false;
    return true;
  }
};

// processors/AliasGenerator.ts
var AliasGenerator = class {
  constructor(app, settings) {
    this.renameHistory = /* @__PURE__ */ new Map();
    this.greekMap = {
      "\\alpha": "alpha",
      "\\beta": "beta",
      "\\gamma": "gamma",
      "\\delta": "delta",
      "\\epsilon": "epsilon",
      "\\phi": "phi",
      "\\mu": "mu",
      "\\lambda": "lambda"
    };
    this.subMap = {
      "\u2080": "0",
      "\u2081": "1",
      "\u2082": "2",
      "\u2083": "3",
      "\u2084": "4",
      "\u2085": "5",
      "\u2086": "6",
      "\u2087": "7",
      "\u2088": "8",
      "\u2089": "9",
      "\u208A": "+",
      "\u208B": "-",
      "\u208C": "=",
      "\u208D": "(",
      "\u208E": ")"
    };
    this.supMap = {
      "\u2070": "0",
      "\xB9": "1",
      "\xB2": "2",
      "\xB3": "3",
      "\u2074": "4",
      "\u2075": "5",
      "\u2076": "6",
      "\u2077": "7",
      "\u2078": "8",
      "\u2079": "9",
      "\u207A": "+",
      "\u207B": "-",
      "\u207D": "(",
      "\u207E": ")"
    };
    this.reverseSubMap = {
      "0": "_0",
      "1": "_1",
      "2": "_2",
      "3": "_3",
      "4": "_4",
      "5": "_5",
      "6": "_6",
      "7": "_7",
      "8": "_8",
      "9": "_9",
      "+": "_+",
      "-": "_-"
    };
    this.reverseSupMap = {
      "+": "^+",
      "-": "^-"
    };
    this.app = app;
    this.settings = settings;
    this.fmOps = new FrontmatterSafeOps(app);
  }
  async process(files, history) {
    if (history) this.renameHistory = history;
    let count = 0;
    for (const file of files) {
      if (file.basename.startsWith("Untitled")) continue;
      const modified = await this.fmOps.updateAliases(file, (roots) => {
        return this.generateFromRoots(roots, file.path);
      });
      if (modified) count++;
    }
    return count;
  }
  generateFromRoots(roots, filePath) {
    if (this.renameHistory.has(filePath)) {
      const historyItem = this.renameHistory.get(filePath);
      if (historyItem) roots.add(historyItem);
    }
    const finalAliases = /* @__PURE__ */ new Set();
    const generationSeeds = /* @__PURE__ */ new Set();
    for (const root of roots) {
      if (root.includes("$") || this.hasSpecialChars(root)) {
        finalAliases.add(root);
        const ascii = this.normalizeScientificText(root);
        if (ascii !== root && ascii.length >= 2) {
          finalAliases.add(ascii);
          generationSeeds.add(ascii);
        }
        if (!root.includes("$") && this.hasSpecialChars(root)) {
          const latex = this.unicodeToLatex(root);
          if (latex !== root) finalAliases.add(latex);
        }
        continue;
      }
      let clean = root;
      if (clean.startsWith("_") && clean.endsWith("_")) {
        clean = clean.replace(/^_+|_+$/g, "");
      }
      if (/s{3,}$/.test(clean)) continue;
      if (clean.length >= 2) generationSeeds.add(clean);
    }
    for (const seed of generationSeeds) {
      finalAliases.add(seed);
      const isChemical = /\d$/.test(seed);
      if (!isChemical) {
        if (!seed.endsWith("ss")) finalAliases.add(seed + "s");
        if (seed.endsWith("s") && !seed.endsWith("ss")) {
          finalAliases.add(seed.slice(0, -1));
        }
      }
      if (this.settings.generateIons && seed.endsWith("ium")) {
        if (seed.toLowerCase() !== "bacterium") {
          finalAliases.add(`${seed} ion`);
        }
      }
      if (this.settings.generateScientificAbbreviations) {
        if (/^[A-Z][a-z]+\s[a-z]+$/.test(seed)) {
          const parts = seed.split(" ");
          if (parts.length === 2) {
            const abbrev = `${parts[0].charAt(0)}. ${parts[1]}`;
            finalAliases.add(abbrev);
          }
        }
      }
      if (seed.endsWith("um")) finalAliases.add(seed.slice(0, -2) + "a");
      if (seed.endsWith("us")) finalAliases.add(seed.slice(0, -2) + "i");
      if (seed.endsWith("is")) finalAliases.add(seed.slice(0, -2) + "es");
      if (seed.endsWith("a") && !seed.endsWith("ia")) finalAliases.add(seed + "e");
    }
    const wrappers = /* @__PURE__ */ new Set();
    for (const item of finalAliases) {
      if (!item.includes("$") && !item.startsWith("_")) {
        wrappers.add(`_${item}_`);
      }
    }
    wrappers.forEach((w) => finalAliases.add(w));
    for (const item of finalAliases) {
      if (!item || item.trim().length === 0) finalAliases.delete(item);
      if (/s{3,}$/.test(item) || /s{3,}_$/.test(item)) finalAliases.delete(item);
    }
    return finalAliases;
  }
  hasSpecialChars(text) {
    return /[₀-₉₊₋₌₍₎⁰-⁹⁺⁻⁽⁾]/.test(text);
  }
  normalizeScientificText(text) {
    let clean = text;
    if (clean.includes("$")) {
      clean = clean.replace(/\$/g, "");
      clean = clean.replace(/[_^{}]/g, "");
      for (const [key, val] of Object.entries(this.greekMap)) {
        const regex = new RegExp(key.replace(/\\/g, "\\\\"), "g");
        clean = clean.replace(regex, val);
      }
      clean = clean.replace(/\\/g, "");
    }
    let ascii = "";
    for (const char of clean) {
      if (this.subMap[char]) ascii += this.subMap[char];
      else if (this.supMap[char]) ascii += this.supMap[char];
      else ascii += char;
    }
    return ascii.trim();
  }
  unicodeToLatex(text) {
    let latex = "";
    let hasSub = false;
    for (const char of text) {
      if (/[₀-₉]/.test(char)) {
        const num = this.subMap[char];
        latex += `_${num}`;
        hasSub = true;
      } else if (/[⁺⁻]/.test(char)) {
        const charge = this.supMap[char];
        latex += `^{${charge}}`;
        hasSub = true;
      } else {
        latex += char;
      }
    }
    if (hasSub) return `$${latex}$`;
    return text;
  }
};

// utils/Tokenizer.ts
var Tokenizer = class {
  static tokenize(text) {
    return text.split(REGEX_PATTERNS.TOKENIZER_SPLIT);
  }
  static isWord(token) {
    return /[a-zA-Z0-9$_\-\u2018\u2019'{}\u2070-\u209F\x2F\\]/.test(token);
  }
};

// processors/WindowMatcher.ts
var WindowMatcher = class {
  static findMatch(tokens, currentIndex, maxWindow, aliasMap, startWords, shortFormRegistry) {
    const firstToken = tokens[currentIndex];
    const cleanFirst = firstToken.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "").toLowerCase();
    if (!startWords.has(cleanFirst)) {
      return { matched: false, advanceIndices: 0, linkText: "", target: "" };
    }
    for (let len = maxWindow; len >= 1; len--) {
      const phraseTokens = [];
      let validWordsFound = 0;
      let offset = 0;
      for (let k = 0; k < 50; k++) {
        if (currentIndex + k >= tokens.length) break;
        const t = tokens[currentIndex + k];
        if (Tokenizer.isWord(t)) {
          phraseTokens.push(t);
          validWordsFound++;
        } else {
          if (validWordsFound < len) phraseTokens.push(t);
        }
        offset = k;
        if (validWordsFound === len) break;
      }
      if (validWordsFound !== len) continue;
      const candidateRaw = phraseTokens.join("");
      const candidateClean = candidateRaw.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
      const candidateKey = candidateClean.replace(/\s+/g, " ").toLowerCase();
      if (aliasMap.has(candidateKey)) {
        const target = aliasMap.get(candidateKey);
        if (!target) continue;
        if (candidateClean.length <= 3) {
          const allowedForms = shortFormRegistry.get(candidateKey);
          if (allowedForms && !allowedForms.has(candidateClean)) {
            continue;
          }
        }
        if (/^\d+$/.test(candidateClean) && !candidateClean.includes("$")) {
          continue;
        }
        return {
          matched: true,
          advanceIndices: offset,
          linkText: candidateRaw,
          target
        };
      }
    }
    return { matched: false, advanceIndices: 0, linkText: "", target: "" };
  }
};

// processors/ContextMasker.ts
var ContextMasker = class {
  constructor() {
    this.masks = [];
  }
  mask(text, aliasMap) {
    this.masks = [];
    let workingText = text;
    const createMask = (match) => {
      if (aliasMap && match.startsWith("$")) {
        const cleanKey = match.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "").toLowerCase();
        if (aliasMap.has(cleanKey)) {
          return match;
        }
      }
      this.masks.push(match);
      return `___MASK_${this.masks.length - 1}___`;
    };
    workingText = workingText.replace(REGEX_PATTERNS.MASK_YAML, createMask);
    workingText = workingText.replace(REGEX_PATTERNS.MASK_CODE, createMask);
    workingText = workingText.replace(REGEX_PATTERNS.MASK_AREAS, createMask);
    return workingText;
  }
  unmask(text) {
    return text.replace(/___MASK_(\d+)___/g, (match, indexStr) => {
      const index = parseInt(indexStr, 10);
      if (index >= 0 && index < this.masks.length) {
        return this.masks[index];
      }
      return match;
    });
  }
  resolveMask(token) {
    const match = token.match(/___MASK_(\d+)___/);
    if (match) {
      const index = parseInt(match[1], 10);
      if (index >= 0 && index < this.masks.length) {
        return this.masks[index];
      }
    }
    return null;
  }
};

// processors/RecursionGuard.ts
var RecursionGuard = class {
  static isSafeToLink(targetBasename, currentFile, candidateText, precedingContext = "") {
    if (precedingContext.trim().endsWith("[")) {
      return false;
    }
    return true;
  }
};

// processors/AutoLinker.ts
var AutoLinker = class {
  constructor(app, uniqueMap, shortFormRegistry, settings) {
    this.maxWindow = 0;
    this.YIELD_THRESHOLD = 1e3;
    this.app = app;
    this.settings = settings;
    this.uniqueMap = uniqueMap;
    this.shortFormRegistry = shortFormRegistry;
    this.masker = new ContextMasker();
    this.startWords = /* @__PURE__ */ new Set();
    for (const key of this.uniqueMap.keys()) {
      const tokens = Tokenizer.tokenize(key);
      const firstWord = tokens.find((t) => Tokenizer.isWord(t));
      if (firstWord) {
        const cleanStart = firstWord.replace(/^[_$]+|[_$]+$/g, "").toLowerCase();
        this.startWords.add(cleanStart);
      }
      const wordCount = tokens.filter((t) => Tokenizer.isWord(t)).length;
      this.maxWindow = Math.max(this.maxWindow, wordCount);
    }
  }
  async yieldToMain() {
    return new Promise((resolve) => setTimeout(resolve, 0));
  }
  async process(files) {
    let count = 0;
    for (const file of files) {
      if (file.extension !== "md") continue;
      try {
        const originalContent = await this.app.vault.read(file);
        const linkedContent = await this.linkText(originalContent, file);
        if (linkedContent === originalContent) continue;
        await this.app.vault.process(file, (currentOnDisk) => {
          if (currentOnDisk !== originalContent) {
            return currentOnDisk;
          }
          count++;
          return linkedContent;
        });
      } catch (e) {
        console.error(`AutoLinker failed: ${file.path}`, e);
      }
    }
    return count;
  }
  async linkText(text, file) {
    let textToProcess = text;
    const tempMasks = [];
    textToProcess = textToProcess.replace(
      /(\[\[(?:[^\]|]+)(?:\|[^\]]+)?\]\]\s*)(\([^)]+\))/g,
      (match, prefix, content) => {
        if (content.length > 100) return match;
        if (!content.includes("$")) {
          return match;
        }
        tempMasks.push(content);
        return `${prefix}___TEMP_DEF_${tempMasks.length - 1}___`;
      }
    );
    if (!this.settings.enableTableLinking) {
      textToProcess = textToProcess.replace(REGEX_PATTERNS.MASK_TABLE_ROW, (m) => {
        tempMasks.push(m);
        return `___TEMP_${tempMasks.length - 1}___`;
      });
    }
    if (!this.settings.linkMathBlocks) {
      textToProcess = textToProcess.replace(/\$[^$]+\$/g, (m) => {
        tempMasks.push(m);
        return `___TEMP_${tempMasks.length - 1}___`;
      });
    }
    this.masker = new ContextMasker();
    const working = this.masker.mask(textToProcess, this.uniqueMap);
    const tokens = Tokenizer.tokenize(working);
    const resultTokens = [...tokens];
    for (let i = 0; i < tokens.length; i++) {
      if (i % this.YIELD_THRESHOLD === 0) await this.yieldToMain();
      const token = tokens[i];
      if (!Tokenizer.isWord(token)) continue;
      if (token.startsWith("___MASK_")) continue;
      if (token.startsWith("___TEMP_")) continue;
      const match = WindowMatcher.findMatch(
        tokens,
        i,
        this.maxWindow,
        this.uniqueMap,
        this.startWords,
        this.shortFormRegistry
      );
      if (match.matched) {
        const prevToken = i > 0 ? tokens[i - 1] : "";
        if (RecursionGuard.isSafeToLink(match.target, file, match.linkText, prevToken)) {
          let link = "";
          let shouldSkip = false;
          if (match.linkText.includes("$")) {
            let lookAheadStr = "";
            const lookAheadLimit = 15;
            for (let k = 1; k < lookAheadLimit; k++) {
              const idx = i + match.advanceIndices + k;
              if (idx >= tokens.length) break;
              lookAheadStr += tokens[idx];
            }
            const unmaskedLookAhead = this.masker.unmask(lookAheadStr);
            const targetPattern = `[[${match.target}]]`;
            if (unmaskedLookAhead.trim().startsWith(targetPattern)) {
              shouldSkip = true;
            } else {
              link = `${match.linkText} [[${match.target}]]`;
            }
          } else {
            link = match.linkText === match.target ? `[[${match.target}]]` : `[[${match.target}|${match.linkText}]]`;
          }
          if (!shouldSkip) {
            resultTokens[i] = link;
            for (let j = 1; j <= match.advanceIndices; j++) {
              resultTokens[i + j] = "";
            }
            i += match.advanceIndices;
          }
        }
      }
    }
    let unmaskedText = this.masker.unmask(resultTokens.join(""));
    unmaskedText = unmaskedText.replace(/___TEMP_(?:DEF_)?(\d+)___/g, (m, i) => tempMasks[parseInt(i, 10)] || m);
    if (this.settings.enableTableLinking) {
      return this.escapeLinksInTables(unmaskedText);
    } else {
      return unmaskedText;
    }
  }
  escapeLinksInTables(text) {
    const lines = text.split(/\r?\n/);
    const tableLineRegex = /^\s*\|.*\|\s*$/;
    for (let i = 0; i < lines.length; i++) {
      if (tableLineRegex.test(lines[i])) {
        lines[i] = lines[i].replace(/\[\[(.*?)\]\]/g, (match, content) => {
          if (!content.includes("|")) return match;
          const parts = content.split(/\\\|/g);
          const fixedParts = parts.map((p) => p.replace(/\|/g, "\\|"));
          return `[[${fixedParts.join("\\|")}]]`;
        });
      }
    }
    return lines.join("\n");
  }
};

// processors/MultiAliasLinker.ts
var MultiAliasLinker = class {
  constructor(app, multiMap, shortFormRegistry, settings) {
    this.app = app;
    this.multiMap = multiMap;
    this.shortFormRegistry = shortFormRegistry;
    this.settings = settings;
    this.masker = new ContextMasker();
  }
  async process(files) {
    let count = 0;
    for (const file of files) {
      if (file.extension !== "md") continue;
      try {
        const originalContent = await this.app.vault.read(file);
        let workingContent = this.unlinkUnsupportedAliases(originalContent);
        workingContent = this.linkAmbiguousTerms(workingContent, file);
        if (workingContent !== originalContent) {
          await this.app.vault.process(file, () => workingContent);
          count++;
        }
      } catch (e) {
        console.error(`MultiAliasLinker failed: ${file.path}`, e);
      }
    }
    return count;
  }
  unlinkUnsupportedAliases(text) {
    return text.replace(
      /\[\[([^\]|]+)(\|([^\]]+))?\]\]/g,
      (match, targetRaw, _pipeGroup, aliasRaw) => {
        const target = targetRaw.trim();
        const alias = (aliasRaw || target).trim();
        const cleanAlias = alias.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "").toLowerCase();
        if (!this.multiMap.has(cleanAlias)) {
          return match;
        }
        const textWithoutLink = text.replace(match, "");
        const candidates = this.multiMap.get(cleanAlias);
        const targetInContext = textWithoutLink.toLowerCase().includes(target.toLowerCase());
        if (!targetInContext) {
          const otherCandidateSupported = candidates.some(
            (c) => c !== target && textWithoutLink.toLowerCase().includes(c.toLowerCase())
          );
          if (otherCandidateSupported) {
            return alias;
          }
        }
        return match;
      }
    );
  }
  linkAmbiguousTerms(text, file) {
    let textToProcess = text;
    const tempMasks = [];
    if (!this.settings.enableTableLinking) {
      textToProcess = textToProcess.replace(REGEX_PATTERNS.MASK_TABLE_ROW, (m) => {
        tempMasks.push(m);
        return `___TEMP_${tempMasks.length - 1}___`;
      });
    }
    if (!this.settings.linkMathBlocks) {
      textToProcess = textToProcess.replace(/\$[^$]+\$/g, (m) => {
        tempMasks.push(m);
        return `___TEMP_${tempMasks.length - 1}___`;
      });
    }
    const working = this.masker.mask(textToProcess, /* @__PURE__ */ new Map());
    const tokens = Tokenizer.tokenize(working);
    const resultTokens = [...tokens];
    for (let i = 0; i < tokens.length; i++) {
      const token = tokens[i];
      if (!Tokenizer.isWord(token)) continue;
      if (token.startsWith("___MASK_")) continue;
      if (token.startsWith("___TEMP_")) continue;
      const cleanToken = token.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
      const key = cleanToken.toLowerCase();
      if (this.multiMap.has(key)) {
        const candidates = this.multiMap.get(key);
        const candidatesInContext = candidates.filter(
          (c) => textToProcess.toLowerCase().includes(c.toLowerCase())
        );
        if (candidatesInContext.length === 1) {
          const target = candidatesInContext[0];
          const prevToken = i > 0 ? tokens[i - 1] : "";
          if (RecursionGuard.isSafeToLink(target, file, cleanToken, prevToken)) {
            const link = cleanToken === target ? `[[${target}]]` : `[[${target}|${cleanToken}]]`;
            resultTokens[i] = link;
          }
        }
      }
    }
    let unmaskedText = this.masker.unmask(resultTokens.join(""));
    unmaskedText = unmaskedText.replace(/___TEMP_(\d+)___/g, (m, i) => tempMasks[parseInt(i, 10)] || m);
    return unmaskedText;
  }
};

// processors/LinkSanitizer.ts
var LinkSanitizer = class {
  constructor(app, indexData) {
    this.app = app;
    this.combinedMap = /* @__PURE__ */ new Map();
    for (const [key, val] of indexData.uniqueMap.entries()) {
      this.combinedMap.set(key, [val]);
    }
    for (const [key, vals] of indexData.multiMap.entries()) {
      this.combinedMap.set(key, vals);
    }
    this.shortFormRegistry = indexData.shortFormRegistry;
  }
  async process(files) {
    let count = 0;
    for (const file of files) {
      if (file.extension !== "md") continue;
      try {
        await this.app.vault.process(file, (text) => {
          const clean = this.sanitizeContent(text);
          if (clean !== text) {
            count++;
            return clean;
          }
          return text;
        });
      } catch (e) {
        console.error(`Sanitizer failed: ${file.path}`, e);
      }
    }
    return count;
  }
  sanitizeContent(text) {
    const masks = [];
    const createMask = (match) => {
      masks.push(match);
      return `___MASK_${masks.length - 1}___`;
    };
    let working = text;
    working = working.replace(REGEX_PATTERNS.MASK_YAML, createMask);
    working = working.replace(REGEX_PATTERNS.MASK_CODE, createMask);
    working = working.replace(/\[\[(.*?)\\+\|\s*/g, "[[$1\\|");
    working = working.replace(REGEX_PATTERNS.LINK_WITH_UNDERSCORE_ALIAS, (match, target, alias) => {
      const inner = alias.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "");
      if (target.toLowerCase() === inner.toLowerCase()) return `_[[${target}]]_`;
      return `_[[${target}|${inner}]]_`;
    });
    const VALIDATION_REGEX = /\[\[([^\]|]+)\|([^\]]+)\]\]/g;
    working = working.replace(VALIDATION_REGEX, (match, targetRaw, aliasRaw) => {
      const target = targetRaw.trim();
      const alias = aliasRaw.trim();
      if (alias.includes("$")) return alias;
      if (target.toLowerCase() === alias.toLowerCase()) {
        return `[[${target}]]`;
      }
      const cleanAlias = alias.replace(REGEX_PATTERNS.UNDERSCORES_WRAPPER, "").toLowerCase();
      if (!this.combinedMap.has(cleanAlias)) return alias;
      const registeredTargets = this.combinedMap.get(cleanAlias);
      if (registeredTargets && !registeredTargets.some((t) => t.toLowerCase() === target.toLowerCase())) {
        return match;
      }
      return match;
    });
    return working.replace(/___MASK_(\d+)___/g, (m, i) => masks[parseInt(i, 10)] || m);
  }
};

// settings/GardenerSettingTab.ts
var import_obsidian3 = require("obsidian");
var GardenerSettingTab = class extends import_obsidian3.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian3.Setting(containerEl).setName("Safety").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Skip confirmation").setDesc("Run immediately without showing the confirmation modal.").addToggle((toggle) => toggle.setValue(this.plugin.settings.skipConfirmationModal).onChange(async (value) => {
      this.plugin.settings.skipConfirmationModal = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Ignored folders").setDesc("Comma-separated list of folders to ignore.").addText((text) => text.setPlaceholder("E.g. templates, archive, bin").setValue(this.plugin.settings.ignoredFolders).onChange(async (value) => {
      this.plugin.settings.ignoredFolders = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Ignored words").setDesc("Comma-separated list of words to never link (e.g. stopwords).").addTextArea((text) => text.setPlaceholder("The, and, or").setValue(this.plugin.settings.ignoredWords).onChange(async (value) => {
      this.plugin.settings.ignoredWords = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Processors").setHeading();
    new import_obsidian3.Setting(containerEl).setName("Filename renamer").setDesc("Renames files based on rules.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableRenamer).onChange(async (value) => {
      this.plugin.settings.enableRenamer = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Alias generator").setDesc("Generates frontmatter aliases automatically.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAliases).onChange(async (value) => {
      this.plugin.settings.enableAliases = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Generate scientific abbreviations").setDesc('E.g. "Escherichia coli" -> "E. coli"').setClass("vault-gardener-setting-indent").addToggle((toggle) => toggle.setValue(this.plugin.settings.generateScientificAbbreviations).onChange(async (value) => {
      this.plugin.settings.generateScientificAbbreviations = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Generate ions").setDesc('E.g. "Magnesium" -> "Mg2+"').setClass("vault-gardener-setting-indent").addToggle((toggle) => toggle.setValue(this.plugin.settings.generateIons).onChange(async (value) => {
      this.plugin.settings.generateIons = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Auto-linker").setDesc("Automatically creates links in text.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableAutoLinker).onChange(async (value) => {
      this.plugin.settings.enableAutoLinker = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Link math blocks").setDesc("If enabled, text inside $...$ may be linked.").setClass("setting-indent").addToggle((toggle) => toggle.setValue(this.plugin.settings.linkMathBlocks).onChange(async (value) => {
      this.plugin.settings.linkMathBlocks = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Link table rows").setDesc("If enabled, text inside tables may be linked.").setClass("setting-indent").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableTableLinking).onChange(async (value) => {
      this.plugin.settings.enableTableLinking = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian3.Setting(containerEl).setName("Link sanitizer").setDesc("Removes redundant links and cleans formatting.").addToggle((toggle) => toggle.setValue(this.plugin.settings.enableSanitizer).onChange(async (value) => {
      this.plugin.settings.enableSanitizer = value;
      await this.plugin.saveSettings();
    }));
  }
};

// modals/ConfirmationModal.ts
var import_obsidian4 = require("obsidian");
var ConfirmationModal = class extends import_obsidian4.Modal {
  constructor(app, settings, onConfirm) {
    super(app);
    this.settings = settings;
    this.onConfirm = onConfirm;
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.empty();
    contentEl.addClass("vault-gardener-confirmation-modal");
    contentEl.createEl("h2", { text: "Confirm cleanup" });
    const list = contentEl.createEl("ul");
    if (this.settings.enableRenamer) list.createEl("li", { text: "Normalize filenames" });
    if (this.settings.enableAliases) list.createEl("li", { text: "Generate aliases" });
    if (this.settings.enableSanitizer) list.createEl("li", { text: "Sanitize links" });
    if (this.settings.enableAutoLinker) list.createEl("li", { text: "Auto-link content" });
    contentEl.createEl("p", { text: "This will modify files in your vault. Make sure you have a backup." });
    new import_obsidian4.Setting(contentEl).addButton((btn) => btn.setButtonText("Cancel").onClick(() => {
      this.close();
    })).addButton((btn) => btn.setButtonText("Run cleanup").setCta().onClick(() => {
      this.close();
      this.onConfirm();
    }));
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// processors/RedundantLinkPatternSanitizer.ts
var RedundantLinkPatternSanitizer = class {
  constructor(app) {
    this.app = app;
  }
  async process(files) {
    let count = 0;
    for (const file of files) {
      if (file.extension !== "md") continue;
      try {
        const originalContent = await this.app.vault.read(file);
        const newContent = this.fixRedundantPatterns(originalContent);
        if (newContent !== originalContent) {
          await this.app.vault.process(file, () => newContent);
          count++;
        }
      } catch (e) {
        console.error(`PatternSanitizer failed: ${file.path}`, e);
      }
    }
    return count;
  }
  fixRedundantPatterns(text) {
    const pattern = /(\[\[([^\]|]+)(?:\|[^\]]+)?\]\])\s*\(\s*(\$[^$]+\$)\s*(\[\[([^\]|]+)(?:\|[^\]]+)?\]\])\s*\)/g;
    return text.replace(pattern, (match, outerFull, outerTarget, mathBlock, innerFull, innerTarget) => {
      const t1 = outerTarget.trim().toLowerCase();
      const t2 = innerTarget.trim().toLowerCase();
      if (t1 !== t2) return match;
      const fixed = `${outerFull} (${mathBlock})`;
      return fixed;
    });
  }
};

// main.ts
var import_obsidian6 = require("obsidian");
var DEFAULT_SETTINGS = {
  enableRenamer: true,
  enableAliases: true,
  enableSanitizer: true,
  enableAutoLinker: true,
  enableTableLinking: false,
  generateScientificAbbreviations: true,
  generateIons: true,
  ignoredWords: "The, and, but, for, not, this, that, with, from, into",
  ignoredFolders: "Templates, archive, bin",
  skipConfirmationModal: false,
  linkMathBlocks: false
};
var VaultGardener = class extends import_obsidian5.Plugin {
  async onload() {
    await this.loadSettings();
    this.statusBarItem = this.addStatusBarItem();
    this.statusBarItem.setText("");
    this.addRibbonIcon("sprout", "Garden", (_evt) => {
      if (this.settings.skipConfirmationModal) {
        void this.runSequence();
      } else {
        new ConfirmationModal(this.app, this.settings, () => {
          void this.runSequence();
        }).open();
      }
    });
    this.addSettingTab(new GardenerSettingTab(this.app, this));
    this.addCommand({
      id: "run-gardener",
      name: "Run cleanup",
      callback: () => {
        if (this.settings.skipConfirmationModal) {
          void this.runSequence();
        } else {
          new ConfirmationModal(this.app, this.settings, () => {
            void this.runSequence();
          }).open();
        }
      }
    });
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async runSequence() {
    new import_obsidian5.Notice("\u{1F331} Gardening started...");
    this.statusBarItem.setText("\u{1F331} Gardening: preparing...");
    const allFiles = this.app.vault.getMarkdownFiles();
    const ignoredPaths = this.settings.ignoredFolders.split(",").map((s) => (0, import_obsidian6.normalizePath)(s.trim())).filter((s) => s.length > 0);
    const files = allFiles.filter((file) => {
      if (file.extension !== "md") return false;
      for (const ignored of ignoredPaths) {
        if (file.path.startsWith(ignored)) return false;
      }
      return true;
    });
    console.debug(`Processing ${files.length} files`);
    const indexer = new AsyncVaultIndex(this.app, this.settings);
    const renamer = new FilenameRenamer(this.app);
    const generator = new AliasGenerator(this.app, this.settings);
    const MAX_LOOPS = 5;
    let loopCount = 0;
    let totalChangesInRun = 0;
    try {
      while (loopCount < MAX_LOOPS) {
        loopCount++;
        let changesThisLoop = 0;
        this.statusBarItem.setText(`\u{1F331} Pass ${loopCount}/${MAX_LOOPS}...`);
        let renameHistory = /* @__PURE__ */ new Map();
        if (this.settings.enableRenamer) {
          renameHistory = await renamer.process(files);
          changesThisLoop += renameHistory.size;
        }
        if (this.settings.enableAliases) {
          const aliasCount = await generator.process(files, renameHistory);
          changesThisLoop += aliasCount;
        }
        if (loopCount === 1) {
          const patternSanitizer = new RedundantLinkPatternSanitizer(this.app);
          const changes = await patternSanitizer.process(files);
          changesThisLoop += changes;
        }
        let indexData = null;
        if (this.settings.enableSanitizer || this.settings.enableAutoLinker) {
          indexData = await indexer.buildIndex(files);
        }
        if (this.settings.enableSanitizer && indexData) {
          const sanitizedCount = await new LinkSanitizer(this.app, indexData).process(files);
          changesThisLoop += sanitizedCount;
          if (sanitizedCount > 0) {
            await this.sleep(300);
          }
        }
        if (this.settings.enableAutoLinker && indexData) {
          if (loopCount === 1) {
            const multiLinker = new MultiAliasLinker(
              this.app,
              indexData.multiMap,
              indexData.shortFormRegistry,
              this.settings
            );
            const multiCount = await multiLinker.process(files);
            changesThisLoop += multiCount;
            console.debug(`[Pass 1] MultiAliasLinker changed ${multiCount} links.`);
          }
          const autoLinker = new AutoLinker(
            this.app,
            indexData.uniqueMap,
            indexData.shortFormRegistry,
            this.settings
          );
          const linkedCount = await autoLinker.process(files);
          changesThisLoop += linkedCount;
        }
        totalChangesInRun += changesThisLoop;
        console.debug(`Pass ${loopCount} complete. Changes: ${changesThisLoop}`);
        if (changesThisLoop === 0) {
          console.debug("Vault is stable. Stopping.");
          break;
        }
      }
      new import_obsidian5.Notice(`\u{1F331} Gardening complete! (changes: ${totalChangesInRun})`);
    } catch (e) {
      console.error("Gardener failed:", e);
      new import_obsidian5.Notice("\u274C Error. Check console.");
    } finally {
      this.statusBarItem.setText("");
    }
  }
  sleep(ms) {
    return new Promise((resolve) => window.setTimeout(resolve, ms));
  }
};
